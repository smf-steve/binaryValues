Should this be converted to a number in the prototype
 ".75"   <-  "11".properFractionFromBinarySequence()

///  README File:  binaryObject.js
///
///  Purpose:
///     To provide a set of operations that manipuate binary values.
///
///     Javascript supports binary literals. The support for binary values are limited to these 
///		binary literals. Hence, literals are just a represention of a number.  Such literals conform 
///		to the following syntax:
///             [+-]? 0b [01]+ ( '.' [01]+)?
///
///     There is limited support for the manipulation of these binary numbers from 
///     two major perspectives:
///         1. the individual bit values are opaque (hidden)
///         2. visual manipulation of these bits is not possible
///
///     With BinaryValues.js, we expose the individual bits so that basic operations 
///     on these bits can be seen and so that we can construct other operations that 
///     perfrom bit-wise manipulations.  In short, binaryValues are just a restricted
///     set of strings.
///
///     These strings conform to the following syntax:
///             [+-]? [01]* ( '.' [01]+ ( ^* [+-]? [01]+ )? )?
///
///     For visual clarity, an underscore can be used within a binary value.
/// 
///     Our primary goal is to expose these operations for demonstrative and learning
///     purposes.  For example, conversion of a real number into a float32 can be more
///     easily demostrated.  
///
///         D = {sign" '', whole: 5, fractional: 75, exponentSign: '', exponent: '' } = (5.75).toDecimalComponents();
///
///         B = (5).toBinaryValue() + '.' + (75).fractionalPartToBinarySequence(4);
///				or
///         B = (5).toBinaryValue() + '.' + (.75).properFractionalToBinarySequence(4);
///
///         B =  "101" +  '.' + "1100";
///			B =  "101.1100";
///         E =  B.toExponentialBinaryValue();
///         E =  "1.01_1100 *^ 10";
///
///         C = E.toBinaryComponents();
///         C = {sign: '', 
///              whole: "1", fractional: "011100",
///              exponentSign: '',
///              exponent: "10"
///             };
///         
///         F.sign = (C.sign == "-') ? "1" : "0";
///         F.mantissa = C.fractional.substring(0,20);
///         F.expontent =  binaryAdd( E.exponent, (16).toBinary()); // add the bias
///  
///         Note that binaryAdd() is not part of "binaryValues.js"
///         We envision that this can be added by "binaryValuesMath.js"
///   
///  Standard Terminology:
///     asciiString:       an array of bytes, with each byte encoding an ascii value
///     binaryString:      a sequence of bytes, which may encode all different types of binary data
///		properFraction:	   a positive number, say f, that meets the condition 0 < f < 1.
///		fractionalPart:    the part of the real number that is to the right of the radix point
///
///  Introduced Terminology:
///     binarySequence:    a non-empty ascii string composed of solely binary digits. Addition punctuation
///                        characters ([_, \t]) may be provided for visual clarity.
///
///     binaryValue:       a string that is either a binaryInteger, binaryReal, or binaryExponential
///
///     binaryInteger:     a value with the syntax of: [+-]? binarySequence 
///     binaryReal:        a value with the syntax of: binaryInteger '.' binarySequence
///		binaryFraction:    a value with the syntax of: '.' binarySequence     						(note there is no leading zero)
///     binaryExponential: a value with the syntax of: binaryReal '*^' [+-]? binaryInteger  
///
///     binaryComponents:  an object containing the various components of a binaryValue
///         {
///             sign          : [+-]?            // empty string denotes non-negative
///             whole         : binarySequence?  // empty string denotes fractional value 
///             fractional    : binarySequence?  // empty string denotes no value
///             exponentSign  : [+-]?            // empty string denotes non-negative
///             exponent      : binarySequence?  // empty string denotes no value
///         }
///		decimalComponents: an object conatinain the various components of a decimalValue.
///			Mirrors the structure of binaryComponents
///
///  Examples of binary values as a string and as binaryComponents
///         Integers:       
///              01001           = { sign: '' ,  whole:  '01001', fractional:      '',  exponentSign: '',  exponent:    '' }
///             -10101           = { sign: '-' , whole:  '10101', fractional:      '',  exponentSign: '',  exponent:    '' }
///             +00101           = { sign: '+' , whole:  '00101', fractional:      '',  exponentSign: '',  exponent:    '' }
///         Reals:    
///              010010.0        = { sign: '' ,  whole: '010010', fractional:     '0',  exponentSign: '',  exponent:    '' }
///             -010010.101      = { sign: '-' , whole: '010010', fractional:   '101',  exponentSign: '',  exponent:    '' } 
///             +010010.01       = { sign: '+' , whole: '010010', fractional:    '01',  exponentSign: '',  exponent:    '' } 
///             -0.00010         = { sign: '-' , whole:      '0', fractional: '00010',  exponentSign: '',  exponent:    '' }
///         Exponentials:   
///              010.010 *^ +01  = { sign: '' ,  whole:    '010', fractional:  '010',   exponentSign: '+', exponent:  '01' }
///             -1010.10 *^ -101 = { sign: '-' , whole:   '1010', fractional:   '10',   exponentSign: '-', exponent: '101' }
///             +001.010 *^ 0    = { sign: '+' , whole:    '001', fractional:  '010',   exponentSign:  '', exponent:   '0' }
///
///         Notes:
///             * BinaryValues are always stored without punctuation characters
///             * BinaryValues are not necessarily store in a normalized or pure form, 
///                 e.g, the binaryReal "0010001.0000" is valid, and in its pure form is: "10001.0"
///             * The binaryValue representing zero is never associated with a sign
///             * Methods exist to either normalize binaryValues or to demote them to a simpler form.
///				* The default maximum number of fractional bits is set to 23, which is the size of the manitissa in IEEE float32
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///  ObjectMethods:
///     Constructors
///         binaryObject            <- new binaryObject()
///         binaryObject            <- new binaryObject(Number)  
///         binaryObject            <- new binaryObject(binaryValue)
///         binaryObject            <- new binaryObject(binaryComponents)
///
///     Get Methods
///         binaryValue             <- binaryObject.get() 
///         binaryComponents        <- binaryObject.getComponents() 
///         char                    <- binaryObject.getSign() 
///         binarySequence          <- binaryObject.getWhole() 
///         binarySequence          <- binaryObject.getFractional() 
///         char                    <- binaryObject.getExponentSign() 
///         binarySequence          <- binaryObject.getExponent() 
///
///     Set Methods 
///         binaryObject            <- binaryObject.set( binaryValue ) 
///         binaryObject            <- binaryObject.setComponents( binaryComponents ) 
///         binaryObject            <- binaryObject.setSign( [ +-] ) 
///         binaryObject            <- binaryObject.setWhole( binarySequence ) 
///         binaryObject            <- binaryObject.setFractional( binarySequence ) 
///         binaryObject            <- binaryObject.setExponentSign( [ +-] ) 
///         binaryObject            <- binaryObject.setExponent( binarySequence ) 
///
///         NOTE that using individual set methods could leave the object in an inconsistent state.
///            For example, having a defined exponentSign without a defined exponent is inconsistent.
///            For such cases, binaryObject.get() and binaryObject.getComponents returns NaN.
///
///     Format Inquiry, Simplification, and Adjustments on BinaryObject
///
///			String 					<- binaryObject.format() 							//  Where the output string is: {"integer", "real", "exponential", "NaN"} 
///         Boolean                 <- binaryObject.isValid()  
///
///         Boolean        		    <- binaryObject.isZero() 							// Returns false if the object's value is NOT zero
///         Boolean		            <- binaryObject.isNormalized() 						// Returns false if not a normalized binaryObject
///      
///         binaryObject            <- binaryObject.normalize()                       	//  Converts to normalized exponential form with trimming
///         binaryObject            <- binaryObject.exponential()                      	//  Converts to normalized exponential form without trimming
///         binaryObject            <- binaryObject.adjustExponent(Number)  			//  Adjusts exponential represention to a desired exponent
///
///         binaryObject            <- binaryObject.flatten()                        	//  Converts from exponential form to a real form
///         binaryObject            <- binaryObject.demote()                          	//  Converts representation to the simpliest form
///
///         binaryObject            <- binaryObject.trim()                            	//  Removes superfluous leading and trailing 0s from all components fof a binaryValue
///
///         binaryObject            <- binaryObject.toFixed(fractionalBits=23)          // 	Sets the number of fractional digits 
///         binaryObject            <- binaryObject.toPrecision(totalBits=24)         	// 	Sets the total number of primary (nonsuperfluous) binary digits
///
///
///		Static Methods that have a String as arguement
///			We anticpate that a user will utilize the Number/String prototypes as opposed to directly calling these methods
///
///         binaryComponents        <- binaryObject.toBinaryComponents(String)                  // returns NaN   if NOT a BinaryValue
///         decimalComponents       <- binaryObject.toDecimalComponents(Number)                 // returns NaN   if NOT a BinaryValue
///
///			Boolean                 <- binaryObject.isBinaryValue(String)						// returns false if not a BinaryValue
///			binaryValue             <- binaryObject.toBinaryValue(String, fractionalBits)		//  "100.01"  <- binaryObject.toBinaryValue(4.25)
///
///		    Boolean                 <- binaryObject.isBinarySequence(String) 			        // Returns false if not a BinarySequence
///        
///			Boolean  	        	<- binaryObject.isZeroBinaryValue(String) 			        // Returns false if the value of the "String" is not zero
///			Boolean      			<- binaryObject.isNormalizedBinaryValue(String) 	        // Returns false if not a normalized binaryValue
///        
///
///         binarySequence          <- binaryObject.trimStartBinarySequence(String)                 
///         binarySequence          <- binaryObject.trimEndBinarySequence(String)     
///
///         binaryValue             <- binaryObject.toBinaryValue(Number, fractionalBits) 	   
///
///         binaryFraction          <- binaryObject.properFractionToBinaryFraction(Number, fractionalBits)      //     ".1"  <- binaryObject.properFractionToBinaryValue(0.5)
///         binaryFraction          <- binaryObject.fractionalPartToBinaryFraction(Number, fractionalBits)      //      "1"  <- binaryObject.fractionalPartToBinaryValue(5)
///  
///			Number  				<- binaryObject.numberFromBinaryValue(String)                               //     "25"  <- binaryObject.numberFromBinaryValue("1.1001  *^ 100")
///			String					<- binaryObject.exponentialFromBinaryValue(String)	                        //   "2.5E1" <- binaryObject.exponentialFromBinaryValue("1.1001  *^ 100")
///  
///			0 <= integer            <- binaryObject.integerToBinarySequence(Number)                             //   "11001" <- binaryObject.integerToBinarySequence(25)
/// 
///         binarySequence          <- binaryObject.numberToBinaryFraction(val, limit, fractionalBits)          //  "1100" <- binaryObject.numberToBinaryFraction(75, 100, 4)
///         0 <= real < 1           <- binaryObject.properFractionToBinarySequence(Number, fractionalBits)      //  "1100" <- binaryObject.properFractionToBinarySequence(0.75, 4)
///         0 <= real < 1           <- binaryObject.fractionalPartToBinarySequence(Number, fractionalBits)      //  "1100" <- binaryObject.fractionalPartToBinarySequence(75, 4)
///  
///			0 <= integer            <- binaryObject.integerFromBinarySequence(String)					        //    "26"  <- binaryObject.integerFromBinarySequence("11010")
///         0 <= real < 1           <- binaryObject.properFractionFromBinarySequence(String)                    //   ".75"  <- binaryObject.properFractionFromBinarySequence("11")
///         0 <= real < 1           <- binaryObject.fractionalPartFromBinarySequence(String)                    //   "75"  <- binaryObject.fractionalPartFromBinarySequence("11")
///
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///     String Prototypes for BinaryValues represented as strings:
///
///         Boolean                 <- "binaryValue".isBinaryValue()                                             // returns false if NOT a BinaryValue
///         Boolean                 <- "binaryValue".isBinarySequence()                                          // Returns false if NOT a BinarySequence
///         Boolean                 <- "binaryValue".isZeroBinaryValue() 						                 // Returns false if the value is not zero
///         Boolean                 <- "binaryValue".isNormalizedBinaryValue() 				                     // Returns false if not a normalized binaryValue
///                
///         binaryValue             <- "binaryValue".normalizeBinaryValue()                                      // Converts to normalized exponential form
///         binaryValue             <- "binaryValue".toExponentialBinaryValue()                                  // Converts to expontial form
///         binaryValue             <- "binaryValue".adjustExponentBinaryValue(Number)                           // Adjusts exponential represention to a desired exponent
///              
///         binaryValue             <- "binaryValue".flattenBinaryValue()                                        // Converts from exponential form to a binaryReal
///         binaryValue             <- "binaryValue".demoteBinaryValue()                                         // Converts representation to the simpliest valid form: binaryInteger or binaryReal
///              
///         binaryValue             <- "binaryValue".trimBinaryValue()                                           // Removes superfluous leading and trailing 0s from all components of a binaryValue
///         binaryValue             <- "binaryValue".trimStartBinarySequence()                                  
///         binaryValue             <- "binaryValue".trimEndBinarySequence()                                
///         
///         binaryValue             <- "binaryValue".toFixedBinaryValue(fractionalBits=23)                       // Sets the number of fractional digits 
///         binaryValue             <- "binaryValue".toPrecisionBinaryValue(totalBits=24)                        // Sets the total number of primary (nonsuperfluous) binary digits
///
///
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///     Number Conversion Prototypes:
///
///			Number can be represented as either a number or a string.
///
///         Results are numbers within their string representational form.
///         Results are always presented in their simpliest form.
///         	Note the .toString() method can be used to convert Interger/Real/Exponential to a binary number, eg., (3.4E-1).toString(2);   
///         	But we want these methods to exist for demonstration purposes.
///
///
///         decimalComponents       <- (Number).toDecimalComponents()                                     // 	Returns NaN if NOT a decimal value
///         decimalComponents       <- "Number".toDecimalComponents()                                     // 	Returns NaN if NOT a decimal value
/// 
///			Number  				<- "binaryValue".numberFromBinaryValue()						      //        25 <- "1.10010 *^ 100".numberFromBinaryValue()
///	        String					<- "binaryValue".exponentialFromBinaryValue()				          //   "2.5E1" <- "1.10010 *^ 100".exponentialFromBinaryValue()
///
///			Sould the following be converted to a Number.  If so, do it in the prototypes.
///			0 <= integer            <- "binarySequence".integerFromBinarySequence()			              //    "26"   <- "11010".integerFromBinarySequence()
///         0 <= real < 1           <- "binarySequence".properFractionFromBinarySequence()                //   ".75"   <-  "11".properFractionFromBinarySequence()
///         0 <= real < 1           <- "binarySequence".fractionalPartFromBinarySequence()                //    "75"   <-  "11".fractionalPartFromBinarySequence()
///              
///
/// 	Prototypes   Number --> Binary*
///
///         binaryComponents        <- "binaryValue".toBinaryComponents()                                 // 	Returns NaN if NOT a binary value
///
///         binaryValue             <- (Number).toBinaryValue(fractionalBits) 	   	                      //   "100.01" <- (4.25).toBinaryValue()
///			binaryValue 			<- "Number".toBinaryValue(fractionalBits)                             //   "100.01" <- "4.25".toBinaryValue()
///
///         binarySequence         	<- (Number).integerToBinarySequence()                                 //    "11001" <- (25).integerToBinarySequence()
///         binarySequence          <- "Number".integerToBinarySequence()                                 //    "11001" <- "25".integerToBinarySequence()
///
///         binarySequence         	<- (Number).numberToBinaryFraction(limit, fractionalBits)             //    "11001" <- (25).integerToBinarySequence()
///         binarySequence          <- "Number".numberToBinaryFraction(limit, fractionalBits)             //    "11001" <- "25".integerToBinarySequence()
///
///         binaryFraction          <- (Number).properFractionToBinaryFraction(fractionalBits)    	      //      "0.1" <- (0.5).properFractionToBinaryValue()
///         binaryFraction          <- "Number".properFractionToBinaryFraction(fractionalBits)            //      "0.1" <- "0.5".ProperFractionToBinaryValue()
///
///         binaryFraction          <- (Number).fractionalPartToBinaryFraction(fractionalBits)    	      //      "0.1" <- (5).fractionalPartToBinaryValue()
///         binaryFraction          <- "Number".fractionalPartToBinaryFraction(fractionalBits)            //      "0.1" <- "5".fractionalPartToBinaryValue()
/// 
///         binarySequence          <- (Number).properFractionToBinarySequence(fractionalBits)            //     "11" <- (0.75).fractionToBinarySequence()
///         binarySequence          <- "Number".properFractionToBinarySequence(fractionalBits)            //     "11" <- "0.75".fractionToBinarySequence()
/// 
///         binarySequence          <- (Number).fractionalPartToBinarySequence(fractionalBits)            //     "11" <- (0.75).fractionalPartToBinarySequence()
///         binarySequence          <- "Number".fractionalPartToBinarySequence(fractionalBits)            //     "11" <- "0.75".fractionalPartToBinarySequence()
/// 
///												
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

